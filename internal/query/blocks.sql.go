// Code generated by sqlc. DO NOT EDIT.
// source: blocks.sql

package query

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/immernote/immernote/internal/types"
	"github.com/jackc/pgtype"
)

const createBlock = `-- name: CreateBlock :exec
INSERT INTO public.blocks ("id", "type", "rank", "content", "format", "space_id", "created_by", "modified_by")
  VALUES ($1, $2, (
      SELECT
        -- Pages are by default inserted at the end
        -- Start at 1, in case we have to move the page to first position
        (COUNT(*) + 1)::text
      FROM
        public.blocks b
      WHERE
        b.space_id = $3
        -- Avoid comparing NULL
        AND (
          CASE WHEN $4::boolean THEN
            -- Lookup all siblings from block_edges
            b.id = ANY (
              SELECT
                be.block_id
              FROM
                public.block_edges be
              WHERE
                be.parent_id = $5::uuid)
            ELSE
              -- Only root pages have no parent_id, so select those from page_sets
              b.id = ANY ( SELECT DISTINCT
                  ps.root_id
                FROM
                  public.page_sets ps
                WHERE
                  ps.root_id = ANY (
                    SELECT
                      bb.id
                    FROM
                      public.blocks bb
                    WHERE
                      bb.space_id = $3))
          END)),
      $6,
      $7,
      $3,
      $8,
      $8)
`

type CreateBlockParams struct {
	ID          uuid.UUID `json:"id"`
	Type        string    `json:"type"`
	SpaceID     uuid.UUID `json:"space_id"`
	SetParentID bool      `json:"set_parent_id"`
	ParentID    uuid.UUID `json:"parent_id"`
	Content     types.Map `json:"content"`
	Format      types.Map `json:"format"`
	CreatedBy   uuid.UUID `json:"created_by"`
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) error {
	_, err := q.db.Exec(ctx, createBlock,
		arg.ID,
		arg.Type,
		arg.SpaceID,
		arg.SetParentID,
		arg.ParentID,
		arg.Content,
		arg.Format,
		arg.CreatedBy,
	)
	return err
}

const getBlock = `-- name: GetBlock :one
SELECT
  id, type, rank, content, format, space_id, created_by, modified_by, created_at, modified_at, deleted_at,
  COALESCE((
    SELECT
      array_to_json(array_agg(row_to_json(tmp)))
    FROM (
      SELECT
        cb.id, cb.rank FROM blocks cb
      WHERE
        cb.id = ANY (
          SELECT
            be.block_id FROM public.block_edges be
          WHERE
            be.parent_id = b.id)) AS tmp), '[]')::children_list AS children
FROM
  public.blocks b
WHERE
  b.id = $1
`

type GetBlockRow struct {
	ID         uuid.UUID            `json:"id"`
	Type       string               `json:"type"`
	Rank       string               `json:"rank"`
	Content    types.Map            `json:"content"`
	Format     types.Map            `json:"format"`
	SpaceID    uuid.UUID            `json:"space_id"`
	CreatedBy  uuid.UUID            `json:"created_by"`
	ModifiedBy uuid.UUID            `json:"modified_by"`
	CreatedAt  time.Time            `json:"created_at"`
	ModifiedAt time.Time            `json:"modified_at"`
	DeletedAt  pgtype.Timestamptz   `json:"deleted_at"`
	Children   types.RankedChildren `json:"children"`
}

func (q *Queries) GetBlock(ctx context.Context, id uuid.UUID) (GetBlockRow, error) {
	row := q.db.QueryRow(ctx, getBlock, id)
	var i GetBlockRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Rank,
		&i.Content,
		&i.Format,
		&i.SpaceID,
		&i.CreatedBy,
		&i.ModifiedBy,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.Children,
	)
	return i, err
}

const listBlocks = `-- name: ListBlocks :many
SELECT
  id, type, rank, content, format, space_id, created_by, modified_by, created_at, modified_at, deleted_at,
  COALESCE((
    SELECT
      array_to_json(array_agg(row_to_json(tmp)))
    FROM (
      SELECT
        cb.id, cb.rank FROM blocks cb
      WHERE
        cb.id = ANY (
          SELECT
            be.block_id FROM public.block_edges be
          WHERE
            be.parent_id = b.id)) AS tmp), '[]')::children_list AS children
FROM
  public.blocks b
WHERE (
  -- Type
  CASE WHEN $1::boolean THEN
    b.type = $2::text
  ELSE
    TRUE
  END)
  AND (
    -- IDs
    CASE WHEN $3::boolean THEN
      b.id = ANY ($4::uuid[])
    ELSE
      TRUE
    END)
  AND (
    -- ParentID
    CASE WHEN $5::boolean THEN
      b.id = (
        SELECT
          be.block_id
        FROM
          public.block_edges be
        WHERE
          be.parent_id = $6::uuid)
      ELSE
        TRUE
    END)
AND (
  -- PageID
  CASE WHEN $7::boolean THEN
    b.id = (
      SELECT
        pb.block_id
      FROM
        public.page_blocks pb
      WHERE
        pb.page_id = $8::uuid)
    ELSE
      TRUE
  END)
AND (
  -- SpaceID
  CASE WHEN $9::boolean THEN
    b.space_id = $10::uuid
  ELSE
    TRUE
  END)
AND (
  -- SpaceHandle
  CASE WHEN $11::boolean THEN
    b.space_id = (
      SELECT
        s.id
      FROM
        public.spaces s
      WHERE
        s.handle = $12::text)
    ELSE
      TRUE
  END)
`

type ListBlocksParams struct {
	SetType        bool        `json:"set_type"`
	Type           string      `json:"type"`
	SetIds         bool        `json:"set_ids"`
	Ids            []uuid.UUID `json:"ids"`
	SetParentID    bool        `json:"set_parent_id"`
	ParentID       uuid.UUID   `json:"parent_id"`
	SetPageID      bool        `json:"set_page_id"`
	PageID         uuid.UUID   `json:"page_id"`
	SetSpaceID     bool        `json:"set_space_id"`
	SpaceID        uuid.UUID   `json:"space_id"`
	SetSpaceHandle bool        `json:"set_space_handle"`
	SpaceHandle    string      `json:"space_handle"`
}

type ListBlocksRow struct {
	ID         uuid.UUID            `json:"id"`
	Type       string               `json:"type"`
	Rank       string               `json:"rank"`
	Content    types.Map            `json:"content"`
	Format     types.Map            `json:"format"`
	SpaceID    uuid.UUID            `json:"space_id"`
	CreatedBy  uuid.UUID            `json:"created_by"`
	ModifiedBy uuid.UUID            `json:"modified_by"`
	CreatedAt  time.Time            `json:"created_at"`
	ModifiedAt time.Time            `json:"modified_at"`
	DeletedAt  pgtype.Timestamptz   `json:"deleted_at"`
	Children   types.RankedChildren `json:"children"`
}

func (q *Queries) ListBlocks(ctx context.Context, arg ListBlocksParams) ([]ListBlocksRow, error) {
	rows, err := q.db.Query(ctx, listBlocks,
		arg.SetType,
		arg.Type,
		arg.SetIds,
		arg.Ids,
		arg.SetParentID,
		arg.ParentID,
		arg.SetPageID,
		arg.PageID,
		arg.SetSpaceID,
		arg.SpaceID,
		arg.SetSpaceHandle,
		arg.SpaceHandle,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBlocksRow{}
	for rows.Next() {
		var i ListBlocksRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Rank,
			&i.Content,
			&i.Format,
			&i.SpaceID,
			&i.CreatedBy,
			&i.ModifiedBy,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlockContent = `-- name: UpdateBlockContent :one
UPDATE
  public.blocks
SET
  content = $1
WHERE
  id = $2
RETURNING
  id, type, rank, content, format, space_id, created_by, modified_by, created_at, modified_at, deleted_at
`

type UpdateBlockContentParams struct {
	Content types.Map `json:"content"`
	ID      uuid.UUID `json:"id"`
}

func (q *Queries) UpdateBlockContent(ctx context.Context, arg UpdateBlockContentParams) (Block, error) {
	row := q.db.QueryRow(ctx, updateBlockContent, arg.Content, arg.ID)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Rank,
		&i.Content,
		&i.Format,
		&i.SpaceID,
		&i.CreatedBy,
		&i.ModifiedBy,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}
